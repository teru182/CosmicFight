<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Cosmic Fight!</title>
  <style>
    /* ページ全体の余白をなくして、背景を黒にする */
    body { margin: 0; overflow: hidden; background: black; }
    /* canvasもブロック表示にして、背景を黒にする */
    canvas { display: block; background: black; }
  </style>
</head>
<body>
  <!-- ゲーム描画用のキャンバス -->
  <canvas id="gameCanvas"></canvas>
  <script>
    // --- キャンバスの初期設定 ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let WIDTH = window.innerWidth;
    let HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    window.addEventListener("resize", () => {
      WIDTH = window.innerWidth;
      HEIGHT = window.innerHeight;
      canvas.width = WIDTH;
      canvas.height = HEIGHT;
      minPlayerY = HEIGHT * 0.5;
      maxPlayerY = HEIGHT - player.height;
    });

    // --- ユーティリティ関数 ---
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for(let i = 0; i < 6; i++){
        color += letters[Math.floor(Math.random()*16)];
      }
      return color;
    }

    // --- ゲームの状態管理 ---
    let gameState = "demo";
    let gameOverTimer = 0;
    let keys = {};
    let canShoot = true;

    // --- キーボード操作 ---
    document.addEventListener("keydown", (e) => {
      keys[e.code] = true;
      if(gameState === "demo" && e.code === "Space"){
        resetGame();
        gameState = "playing";
      }
    });
    document.addEventListener("keyup", (e) => {
      keys[e.code] = false;
      if(e.code === "Space"){
        canShoot = true;
      }
    });

    // --- タッチ操作 ---
    let touchStartX = null, touchStartY = null;
    let isSwiping = false;
    let swipeTrail = [];
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      if(gameState === "demo"){
        resetGame();
        gameState = "playing";
      }
    });
    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      isSwiping = true;
      swipeTrail.push({ x: touch.clientX, y: touch.clientY });
      player.targetX = touch.clientX - player.width/2;
      player.targetY = touch.clientY - player.height/2;
    });
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      if(isSwiping && swipeTrail.length > 0) {
        const lastPoint = swipeTrail[swipeTrail.length - 1];
        player.targetX = lastPoint.x - player.width/2;
        player.targetY = lastPoint.y - player.height/2;
      } else {
        if(canShoot) {
          missiles.push({
            x: player.x + player.width/2 - 2.5,
            y: player.y,
            width: 5,
            height: 10,
            speed: 7
          });
          canShoot = false;
        }
      }
      swipeTrail = [];
      isSwiping = false;
      touchStartX = null;
      touchStartY = null;
      canShoot = true;
    });

    // --- ゲーム内変数 ---
    let score = 0;
    let stage = 1;
    let timer = 30;
    let timerAccumulator = 0;
    let paused = false;
    let stageCleared = false;
    let pauseTimeRemaining = 0;
    let enemyBulletIntervalMultiplier = 1.0;
    let enemyRotationMultiplier = 1.0;

    // --- プレイヤー設定 ---
    const player = {
      x: WIDTH/2 - 30,
      y: HEIGHT - 70,
      width: 60,
      height: 45,
      speed: 5,
      life: 3,
      targetX: WIDTH/2 - 30,
      targetY: HEIGHT - 70
    };
    let minPlayerY = HEIGHT * 0.5;
    let maxPlayerY = HEIGHT - player.height;
    function getPlayerColor() {
      if(player.life === 3) return "green";
      if(player.life === 2) return "yellow";
      if(player.life === 1) return "red";
      return "white";
    }

    // --- 各種オブジェクト ---
    let missiles = [];
    let enemies = [];
    let pulseEnemies = [];
    let enemyBullets = [];
    let explosions = [];
    let pulseWaves = [];
    let stars = [];
    for(let i = 0; i < 100; i++){
      stars.push({
        x: Math.random()*WIDTH,
        y: Math.random()*HEIGHT,
        radius: Math.random()*1.5+0.5,
        speed: Math.random()*0.5+0.2,
        color: getRandomColor()
      });
    }

    // --- 敵の出現管理 ---
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 2000;

    // --- 爆発エフェクト ---
    function Explosion(x, y) {
      this.x = x;
      this.y = y;
      this.particles = [];
      this.done = false;
      for(let i = 0; i < 20; i++){
        let angle = Math.random()*Math.PI*2;
        let speed = Math.random()*3+2;
        this.particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle)*speed,
          vy: Math.sin(angle)*speed,
          radius: Math.random()*2+1,
          life: 1000,
          alpha: 1
        });
      }
    }
    Explosion.prototype.update = function(dt) {
      this.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        p.alpha = p.life/1000;
      });
      this.particles = this.particles.filter(p => p.life > 0);
      if(this.particles.length === 0){ this.done = true; }
    };
    Explosion.prototype.draw = function(ctx) {
      ctx.save();
      this.particles.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
        ctx.fill();
      });
      ctx.restore();
    };
    function createExplosion(x, y) {
      explosions.push(new Explosion(x, y));
    }

    // --- 敵描画 ---
    function drawTriangle(x, y, size, angle) {
      ctx.save();
      ctx.translate(x + size/2, y + size/2);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, -size/2);
      ctx.lineTo(-size/2, size/2);
      ctx.lineTo(size/2, size/2);
      ctx.closePath();
      ctx.fillStyle = "#555";
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.restore();
    }

    // --- プレイヤー描画 ---
    function drawFighter(x, y, width, height) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = getPlayerColor();
      ctx.beginPath();
      ctx.moveTo(width*0.5, 0);
      ctx.lineTo(width, height*0.5);
      ctx.lineTo(width*0.7, height*0.5);
      ctx.lineTo(width*0.8, height);
      ctx.lineTo(width*0.5, height*0.8);
      ctx.lineTo(width*0.2, height);
      ctx.lineTo(width*0.3, height*0.5);
      ctx.lineTo(0, height*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.restore();
    }

    // --- 照準マーク ---
    function isEnemyAligned() {
      const playerCenterX = player.x + player.width/2;
      for(let i = 0; i < enemies.length; i++){
        const enemyCenterX = enemies[i].x + enemies[i].size/2;
        if(Math.abs(enemyCenterX - playerCenterX) < 20){
          return true;
        }
      }
      return false;
    }
    function drawReticle() {
      const reticleCenterX = player.x + player.width/2;
      const reticleCenterY = player.y + player.height/2 - 200;
      let color = "white";
      if(isEnemyAligned()){
        if(Math.floor(Date.now() / 100) % 2 === 0){
          color = "red";
        } else {
          return;
        }
      }
      ctx.save();
      ctx.setLineDash([5,5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.arc(reticleCenterX, reticleCenterY, 30, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(reticleCenterX - 30, reticleCenterY);
      ctx.lineTo(reticleCenterX + 30, reticleCenterY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(reticleCenterX, reticleCenterY - 30);
      ctx.lineTo(reticleCenterX, reticleCenterY + 30);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // --- demoモード ---
    let demoDirection = 1;
    let demoFireTimer = 0;

    // --- ゲームリセット ---
    function resetGame() {
      score = 0;
      stage = 1;
      timer = 30;
      timerAccumulator = 0;
      paused = false;
      stageCleared = false;
      enemySpawnTimer = 0;
      enemySpawnInterval = 2000;
      enemyBulletIntervalMultiplier = 1.0;
      enemyRotationMultiplier = 1.0;
      player.x = WIDTH/2 - player.width/2;
      player.y = HEIGHT - 70;
      player.targetX = player.x;
      player.targetY = player.y;
      player.life = 3;
      missiles = [];
      enemies = [];
      pulseEnemies = [];
      enemyBullets = [];
      explosions = [];
      pulseWaves = [];
    }

    // --- メインゲームループ ---
    let lastTime = 0;
    function gameLoop(timestamp) {
      let dt = timestamp - lastTime;
      lastTime = timestamp;
      if(gameState==="demo"){
        updateDemo(dt);
      } else if(gameState==="playing"){
        updatePlaying(dt);
      } else if(gameState==="gameover"){
        updateGameOver(dt);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // --- demoモードの更新 ---
    function updateDemo(dt) {
      if(player.x <= 0) { demoDirection = 1; }
      else if(player.x >= WIDTH - player.width) { demoDirection = -1; }
      player.x += player.speed * demoDirection;
      player.y = HEIGHT - 70;
      player.targetX = player.x;
      player.targetY = player.y;
      demoFireTimer += dt;
      if(demoFireTimer >= 500) {
        missiles.push({
          x: player.x + player.width/2 - 2.5,
          y: player.y,
          width: 5,
          height: 10,
          speed: 7
        });
        demoFireTimer = 0;
      }
      updateCommon(dt);
    }

    // --- プレイ中の更新 ---
    function updatePlaying(dt) {
      if(paused) {
        pauseTimeRemaining -= dt;
        if(pauseTimeRemaining <= 0 && stageCleared) {
          stage++;
          if(stage > 1 && stage % 10 === 1) {
            enemyRotationMultiplier = 1.0;
            enemyBulletIntervalMultiplier = 1.0;
            enemySpawnInterval = 2000;
          } else {
            enemyRotationMultiplier *= 1.2;
            enemyBulletIntervalMultiplier *= 0.9;
            enemySpawnInterval = Math.max(500, 2000 - (stage - 1)*200);
          }
          timer = 30;
          timerAccumulator = 0;
          stageCleared = false;
          paused = false;
        }
        return;
      }
      if(keys["ArrowLeft"]) { player.x -= player.speed; player.targetX = player.x; }
      if(keys["ArrowRight"]) { player.x += player.speed; player.targetX = player.x; }
      if(keys["ArrowUp"]) { player.y -= player.speed; player.targetY = player.y; }
      if(keys["ArrowDown"]) { player.y += player.speed; player.targetY = player.y; }
      if(Math.abs(player.targetX - player.x) > 1) {
        player.x += (player.targetX - player.x) * 0.2;
      }
      if(Math.abs(player.targetY - player.y) > 1) {
        player.y += (player.targetY - player.y) * 0.2;
      }
      player.x = Math.max(0, Math.min(WIDTH - player.width, player.x));
      player.y = Math.max(minPlayerY, Math.min(maxPlayerY, player.y));
      if(keys["Space"] && canShoot) {
        missiles.push({
          x: player.x + player.width/2 - 2.5,
          y: player.y,
          width: 5,
          height: 10,
          speed: 7
        });
        canShoot = false;
      }
      updateCommon(dt);
    }

    // --- ゲームオーバー ---
    function updateGameOver(dt) {
      gameOverTimer -= dt;
      if(gameOverTimer <= 0) {
        resetGame();
        gameState = "demo";
      }
    }

    // --- 共通の更新処理 ---
    function updateCommon(dt) {
      timerAccumulator += dt;
      while(timerAccumulator >= 1000) {
        timerAccumulator -= 1000;
        timer--;
        score++;
      }
      if(timer <= 0 && !stageCleared) {
        stageCleared = true;
        paused = true;
        pauseTimeRemaining = 2000;
        score += 100;
        missiles.forEach(m => { createExplosion(m.x + m.width/2, m.y + m.height/2); });
        enemyBullets.forEach(bullet => { createExplosion(bullet.x, bullet.y); });
        enemies.forEach(enemy => { createExplosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2); });
        pulseEnemies.forEach(enemy => { createExplosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2); });
        missiles = [];
        enemyBullets = [];
        enemies = [];
        pulseEnemies = [];
      }
      missiles.forEach(m => { m.y -= m.speed; });
      missiles = missiles.filter(m => m.y + m.height > 0);
      
      enemySpawnTimer += dt;
      if(enemySpawnTimer > enemySpawnInterval) {
        enemySpawnTimer = 0;
        let enemySize = 60;
        let minEnemyX = WIDTH * 0.05;
        let maxEnemyX = WIDTH * 0.95 - enemySize;
        let spawnX = minEnemyX + Math.random() * (maxEnemyX - minEnemyX);
        if(Math.random() < 0.2) {
          pulseEnemies.push({
            type: "pulse",
            x: spawnX,
            y: -enemySize,
            size: enemySize,
            speed: 1.0,
            targetY: HEIGHT * 0.3,
            pulseTimer: 3000,
            pulseInterval: 1000
          });
        } else {
          let effectiveStage = (stage > 1 && stage % 10 === 1) ? 1 : (stage % 10 === 0 ? 10 : stage % 10);
          enemies.push({
            type: "normal",
            x: spawnX,
            y: -enemySize,
            size: enemySize,
            speed: (1 + (effectiveStage - 1) * 0.2) * 1.5,
            bulletTimer: (Math.random() * 2000 + 1000) * enemyBulletIntervalMultiplier,
            angle: 0,
            rotationSpeed: ((Math.random() * 0.05 + 0.02) * 3) * enemyRotationMultiplier
          });
        }
      }
      enemies.forEach(enemy => {
        enemy.y += enemy.speed;
        enemy.angle += enemy.rotationSpeed * dt * 0.001;
        enemy.bulletTimer -= dt;
        if(enemy.bulletTimer <= 0) {
          if(enemy.y < HEIGHT * 0.8) {
            let spawnX = enemy.x + enemy.size/2;
            let spawnY = enemy.y + enemy.size;
            let targetX = player.x + player.width/2;
            let targetY = player.y + player.height/2;
            let dx = targetX - spawnX;
            let dy = targetY - spawnY;
            let distance = Math.sqrt(dx*dx + dy*dy);
            let bulletSpeed = 3 + (stage - 1) * 0.2;
            let speedX = bulletSpeed * (dx/distance);
            let speedY = bulletSpeed * (dy/distance);
            enemyBullets.push({
              x: spawnX,
              y: spawnY,
              radius: 5,
              speedX: speedX,
              speedY: speedY
            });
          }
          enemy.bulletTimer = (Math.random() * 2000 + 1000) * enemyBulletIntervalMultiplier;
        }
      });
      
      // ★ 修正箇所：パルス敵の更新処理 ★
      pulseEnemies.forEach(enemy => {
        if(enemy.y < enemy.targetY) {
          enemy.y += enemy.speed;
        } else {
          enemy.pulseTimer -= dt;
          // プレイヤーに向かってゆっくり追跡する処理
          let enemyCenterX = enemy.x + enemy.size / 2;
          let enemyCenterY = enemy.y + enemy.size / 2;
          let playerCenterX = player.x + player.width / 2;
          let playerCenterY = player.y + player.height / 2;
          let dx = playerCenterX - enemyCenterX;
          let dy = playerCenterY - enemyCenterY;
          let distance = Math.sqrt(dx*dx + dy*dy);
          if(distance > 0) {
            let chaseSpeed = 0.5; // 追跡速度（調整可能）
            enemy.x += (dx / distance) * chaseSpeed;
            enemy.y += (dy / distance) * chaseSpeed;
          }
          if(enemy.pulseTimer <= 0) {
            pulseWaves.push({
              x: enemy.x + enemy.size/2,
              y: enemy.y + enemy.size/2,
              initialRadius: 10,
              radius: 10,
              expansionSpeed: 0.1,
              maxRadius: 300,
              damaged: false
            });
            enemy.pulseTimer = enemy.pulseInterval;
          }
        }
      });
      
      enemies = enemies.filter(enemy => enemy.y < HEIGHT + enemy.size);
      pulseEnemies = pulseEnemies.filter(enemy => enemy.y < HEIGHT + enemy.size);
      enemyBullets.forEach(bullet => {
        bullet.x += bullet.speedX;
        bullet.y += bullet.speedY;
      });
      enemyBullets = enemyBullets.filter(bullet => bullet.x >= 0 && bullet.x <= WIDTH && bullet.y <= HEIGHT + bullet.radius);
      
      for(let i = missiles.length - 1; i >= 0; i--){
        let m = missiles[i];
        for(let j = enemies.length - 1; j >= 0; j--){
          let enemy = enemies[j];
          if(rectIntersect(m, { x: enemy.x, y: enemy.y, width: enemy.size, height: enemy.size })){
            createExplosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2);
            enemies.splice(j, 1);
            missiles.splice(i, 1);
            score += 10;
            break;
          }
        }
      }
      for(let i = missiles.length - 1; i >= 0; i--){
        let m = missiles[i];
        for(let j = pulseEnemies.length - 1; j >= 0; j--){
          let enemy = pulseEnemies[j];
          if(rectIntersect(m, { x: enemy.x, y: enemy.y, width: enemy.size, height: enemy.size })){
            createExplosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2);
            pulseEnemies.splice(j, 1);
            missiles.splice(i, 1);
            score += 10;
            break;
          }
        }
      }
      for(let i = enemies.length - 1; i >= 0; i--){
        let enemy = enemies[i];
        if(rectIntersect({ x: enemy.x, y: enemy.y, width: enemy.size, height: enemy.size }, player)){
          createExplosion(player.x + player.width/2, player.y + player.height/2);
          enemies.splice(i, 1);
          player.life--;
          if(player.life <= 0){
            gameState = "gameover";
            gameOverTimer = 5000;
          }
        }
      }
      for(let i = pulseEnemies.length - 1; i >= 0; i--){
        let enemy = pulseEnemies[i];
        if(rectIntersect({ x: enemy.x, y: enemy.y, width: enemy.size, height: enemy.size }, player)){
          createExplosion(player.x + player.width/2, player.y + player.height/2);
          pulseEnemies.splice(i, 1);
          player.life--;
          if(player.life <= 0){
            gameState = "gameover";
            gameOverTimer = 5000;
          }
        }
      }
      for(let i = enemyBullets.length - 1; i >= 0; i--){
        let bullet = enemyBullets[i];
        if(rectCircleIntersect(player, bullet)){
          createExplosion(player.x + player.width/2, player.y + player.height/2);
          enemyBullets.splice(i,1);
          player.life--;
          if(player.life <= 0){
            gameState = "gameover";
            gameOverTimer = 5000;
          }
        }
      }
      pulseWaves.forEach(wave => {
        wave.radius += wave.expansionSpeed * dt;
        let progress = (wave.radius - wave.initialRadius) / (wave.maxRadius - wave.initialRadius);
        wave.alpha = 1 - progress;
      });
      pulseWaves = pulseWaves.filter(wave => wave.radius < wave.maxRadius);
      pulseWaves.forEach(wave => {
        let playerCenterX = player.x + player.width / 2;
        let playerCenterY = player.y + player.height / 2;
        let playerRadius = (player.width + player.height) / 4;
        let dx = playerCenterX - wave.x;
        let dy = playerCenterY - wave.y;
        let distance = Math.sqrt(dx*dx + dy*dy);
        if(distance < wave.radius + playerRadius && !wave.damaged) {
          createExplosion(player.x + player.width/2, player.y + player.height/2);
          player.life--;
          wave.damaged = true;
          if(player.life <= 0){
            gameState = "gameover";
            gameOverTimer = 5000;
          }
        }
      });
      explosions.forEach(exp => { exp.update(dt); });
      explosions = explosions.filter(exp => !exp.done);
      stars.forEach(star => {
        star.y += star.speed * 1.5;
        if(star.y > HEIGHT){
          star.y = 0;
          star.x = Math.random()*WIDTH;
          star.color = getRandomColor();
        }
      });
    }

    function rectIntersect(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    function rectCircleIntersect(rect, circle) {
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x+rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y+rect.height));
      let dx = circle.x - closestX;
      let dy = circle.y - closestY;
      return (dx*dx+dy*dy) < (circle.radius*circle.radius);
    }

    function draw() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      stars.forEach(star => {
        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI*2);
        ctx.fill();
      });
      if(isSwiping && swipeTrail.length > 0) {
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(swipeTrail[0].x, swipeTrail[0].y);
        for(let i = 1; i < swipeTrail.length; i++){
          ctx.lineTo(swipeTrail[i].x, swipeTrail[i].y);
        }
        ctx.stroke();
      }
      if(gameState!=="gameover"){
        drawFighter(player.x, player.y, player.width, player.height);
        drawReticle();
      }
      ctx.fillStyle = "cyan";
      missiles.forEach(m => {
        ctx.fillRect(m.x, m.y, m.width, m.height);
      });
      enemies.forEach(enemy => {
        drawTriangle(enemy.x, enemy.y, enemy.size, enemy.angle);
      });
      pulseEnemies.forEach(enemy => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(enemy.x + enemy.size/2, enemy.y + enemy.size/2, enemy.size/2, 0, Math.PI*2);
        ctx.fillStyle = "purple";
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.restore();
      });
      ctx.fillStyle = "red";
      enemyBullets.forEach(bullet => {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI*2);
        ctx.fill();
      });
      pulseWaves.forEach(wave => {
        ctx.save();
        ctx.globalAlpha = wave.alpha;
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      });
      explosions.forEach(exp => { exp.draw(ctx); });
      ctx.fillStyle = "white";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.fillText("Life: " + player.life, 10, 60);
      ctx.fillText("Stage: " + stage, 10, 90);
      let blockHeight = 8;
      let gaugeTotalHeight = 30 * blockHeight;
      let startY = (HEIGHT - gaugeTotalHeight) / 2;
      ctx.strokeStyle = "white";
      ctx.strokeRect(WIDTH - 40, startY, 20, gaugeTotalHeight);
      ctx.fillStyle = "blue";
      let currentHeight = timer * blockHeight;
      ctx.fillRect(WIDTH - 40, startY + (gaugeTotalHeight - currentHeight), 20, currentHeight);
      
      if(gameState==="demo"){
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "60px sans-serif";
        ctx.fillText("Cosmic Fight!", WIDTH/2, HEIGHT/3);
        ctx.font = "40px sans-serif";
        ctx.fillText("Push Space Key", WIDTH/2, HEIGHT/2);
      }
      if(gameState==="gameover"){
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "40px sans-serif";
        ctx.fillText("Game Over", WIDTH/2, HEIGHT/2);
      }
      if(gameState==="playing" && paused && stageCleared){
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "40px sans-serif";
        ctx.fillText("Stage Clear! Congratulations!", WIDTH/2, HEIGHT/2);
      }
    }
  </script>
</body>
</html>
